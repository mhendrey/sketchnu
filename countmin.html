<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Count-Min Sketch &mdash; sketchnu 1.2.2 documentation</title><link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Heavy-Hitters" href="heavyhitters.html" />
    <link rel="prev" title="HyperLogLog++" href="hyperloglog.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            sketchnu
              <img src="_static/logo.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                1.2.2
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="hyperloglog.html">HyperLogLog++</a><ul>
<li class="toctree-l2"><a class="reference internal" href="hyperloglog.html#the-basics">The Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="hyperloglog.html#usage">Usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="hyperloglog.html#the-details">The Details</a></li>
<li class="toctree-l2"><a class="reference internal" href="hyperloglog.html#testing">Testing</a></li>
</ul>
</li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Count-Min Sketch</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#the-basics">The Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="#usage">Usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-details">The Details</a></li>
<li class="toctree-l2"><a class="reference internal" href="#testing">Testing</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="heavyhitters.html">Heavy-Hitters</a><ul>
<li class="toctree-l2"><a class="reference internal" href="heavyhitters.html#the-basics">The Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="heavyhitters.html#usage">Usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="heavyhitters.html#the-details">The Details</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="helpers.html">Helper Functions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="helpers.html#usage">Usage</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="hashes.html">Hash Functions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="hashes.html#fasthash">FastHash</a><ul>
<li class="toctree-l3"><a class="reference internal" href="hashes.html#usage">Usage</a></li>
<li class="toctree-l3"><a class="reference internal" href="hashes.html#testing">Testing</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="hashes.html#murmurhash3">MurmurHash3</a><ul>
<li class="toctree-l3"><a class="reference internal" href="hashes.html#id1">Usage</a></li>
<li class="toctree-l3"><a class="reference internal" href="hashes.html#id2">Testing</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="sketchnu.html">sketchnu.hyperloglog</a></li>
<li class="toctree-l1"><a class="reference internal" href="sketchnu.html#module-sketchnu.countmin">sketchnu.countmin</a></li>
<li class="toctree-l1"><a class="reference internal" href="sketchnu.html#module-sketchnu.heavyhitters">sketchnu.heavyhitters</a></li>
<li class="toctree-l1"><a class="reference internal" href="sketchnu.html#module-sketchnu.helpers">sketchnu.helpers</a></li>
<li class="toctree-l1"><a class="reference internal" href="sketchnu.html#module-sketchnu.hashes">sketchnu.hashes</a></li>
<li class="toctree-l1"><a class="reference internal" href="sketchnu.html#sketchnu-tests">sketchnu.tests</a></li>
</ul>
<p class="caption"><span class="caption-text">Admin</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="license.html">License</a><ul>
<li class="toctree-l2"><a class="reference internal" href="license.html#license-requirements">License Requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="license.html#license-notices">License notices</a></li>
<li class="toctree-l2"><a class="reference internal" href="license.html#copyright">Copyright</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="help.html">Help</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">sketchnu</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Count-Min Sketch</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/countmin.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="count-min-sketch">
<h1>Count-Min Sketch<a class="headerlink" href="#count-min-sketch" title="Permalink to this headline">¶</a></h1>
<div class="section" id="the-basics">
<h2>The Basics<a class="headerlink" href="#the-basics" title="Permalink to this headline">¶</a></h2>
<p>A sketch that estimates the number of times a given element has been added into
the sketch. The key benefits for using a count-min sketch are:</p>
<ul class="simple">
<li><p>Fixed memory size no matter the number of distinct elements added</p></li>
<li><p>Saves memory by not storing the keys</p></li>
<li><p>Error guarantees (See <a class="reference internal" href="#the-details">The Details</a> section)</p></li>
<li><p>Easily parallelized across multiple workers, each with their own count-min sketch</p></li>
</ul>
<p>A count-min sketch (cms) is a 2-d array of counters with a width <cite>w</cite> (number of
columns) and depth <cite>d</cite> (number of rows). In this implementation, we provide
three different cms types which determine the number of bytes used for each
counter:</p>
<ul class="simple">
<li><p>linear, 4-bytes</p></li>
<li><p>log16, 2-bytes</p></li>
<li><p>log8, 1-byte</p></li>
</ul>
<p>Each element is associated with <cite>d</cite> counters, one in each of the
<cite>d</cite> rows, by <cite>d</cite> independent hash functions that map the element to
a particular counter (column) in a given row. We use FastHash64 as our hash
function.</p>
<p>For a basic count-min sketch (we implement a modified version), when an element
is added to the sketch simply increment its associated <cite>d</cite> counters by one.
To get an element’s estimated count, simply return the minimum value stored in
the element’s <cite>d</cite> counters.</p>
<p>The width sets the collision rate where two elements map to the same counter in
a given row. A larger width reduces the collision rate. When a collision occurs
the counter will report an estimated count that is higher than the true count.
By using more rows, we ensure that the same two elements will not collide in
the other rows due to the indepence of the hash functions. Therefore, by taking
the minimum of an element’s counters we ensure that the error due to collisions
is minimized. In practice, a good rule of thumb is to have the width greater
than or equal to half the cardinality of the data.</p>
<p>The count-min sketches are implemented as Numba classes. The convenience
function <code class="code docutils literal notranslate"><span class="pre">CountMin()</span></code> is the recommended way to instantiate a count-min sketch
object. The Numba classes are called <code class="code docutils literal notranslate"><span class="pre">CountMinLinear</span></code>, <code class="code docutils literal notranslate"><span class="pre">CountMinLog16</span></code>,
<code class="code docutils literal notranslate"><span class="pre">CountMinLog8</span></code>.</p>
</div>
<div class="section" id="usage">
<h2>Usage<a class="headerlink" href="#usage" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>
<span class="kn">from</span> <span class="nn">sketchnu.countmin</span> <span class="kn">import</span> <span class="n">CountMin</span><span class="p">,</span> <span class="n">load</span>

<span class="c1"># Create a data stream</span>
<span class="n">stream</span> <span class="o">=</span> <span class="p">[</span><span class="sa">b</span><span class="s2">&quot;abc&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;abc&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;abc&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;123&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;123&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;321&quot;</span><span class="p">]</span>

<span class="c1"># Instantiate a linear cms with width = 2**17 and depth = 8</span>
<span class="n">cms</span> <span class="o">=</span> <span class="n">CountMin</span><span class="p">(</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">2</span><span class="o">**</span><span class="mi">17</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>

<span class="c1"># Add a single key</span>
<span class="n">cms</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;key&quot;</span><span class="p">)</span>

<span class="c1"># Add a single key multiple times; faster than calling add(key) multiple times</span>
<span class="n">cms</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;key&quot;</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>

<span class="c1"># Add multiple keys as an iterable</span>
<span class="n">cms</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">stream</span><span class="p">)</span>

<span class="c1"># Add multiple keys as a dict</span>
<span class="c1"># Typically much faster than update([]) assuming any given key appears multiple</span>
<span class="c1"># times in the data stream</span>
<span class="n">cms</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">Counter</span><span class="p">(</span><span class="n">stream</span><span class="p">))</span>

<span class="c1"># Query for the estimated number of times a given key has been seen</span>
<span class="n">n_abc</span> <span class="o">=</span> <span class="n">cms</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abc&quot;</span><span class="p">)</span>
<span class="n">n_123</span> <span class="o">=</span> <span class="n">cms</span><span class="p">[</span><span class="sa">b</span><span class="s2">&quot;123&quot;</span><span class="p">]</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;{n_abc=:} , {n_123=:}&quot;</span><span class="p">)</span>

<span class="c1"># Instantiate a second count-min sketch with same parameters</span>
<span class="n">cms2</span> <span class="o">=</span> <span class="n">CountMin</span><span class="p">(</span><span class="o">**</span><span class="n">cms</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
<span class="c1"># Add the stream to this sketch</span>
<span class="n">cms2</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">Counter</span><span class="p">(</span><span class="n">stream</span><span class="p">))</span>

<span class="c1"># Merge the second into the first</span>
<span class="n">cms</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">cms2</span><span class="p">)</span>
<span class="n">n_abc</span> <span class="o">=</span> <span class="n">cms</span><span class="p">[</span><span class="sa">b</span><span class="s2">&quot;abc&quot;</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;{n_abc=:} after merging&quot;</span><span class="p">)</span>

<span class="c1"># Get the total number of elements added to the sketches</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total elements added = {cms.n_added()}&quot;</span><span class="p">)</span>

<span class="c1"># Save to disk</span>
<span class="n">cms</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s2">&quot;/path/to/save/cms.npz&quot;</span><span class="p">)</span>
<span class="n">cms_load</span> <span class="o">=</span> <span class="n">load</span><span class="p">(</span><span class="s2">&quot;/path/to/save/cms.npz&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="the-details">
<h2>The Details<a class="headerlink" href="#the-details" title="Permalink to this headline">¶</a></h2>
<p>The original algorithm was published in “An Improved Data Stream Summary:
The Count-Min Sketch and its Applications” by Cormode and Muthukrishnan in 2005.
In this paper the authors prove that the estimated count for a given element has
the following guarantees:</p>
<ul class="simple">
<li><p>The true count is less than or equal to the estimated count</p></li>
<li><p>With probability of at least 1 - exp(-d), the estimate &lt;= true + N * exp(1) / w</p></li>
</ul>
<p>where <cite>d</cite> is the depth, <cite>w</cite> is the width, and <cite>N</cite> is the total number of elements
(including duplicates) added to the sketch. So by increasing the width you
reduce the error and by increasing the depth you increase the probability that
you do not exceed the specified error limit.</p>
<p>Over time numerous variations on the original algorithm were developed. See the
2012 paper “Sketch Algorithms for Estimating Point Queries in NLP” by Goyal,
Daume, and Cormode for a good summary.</p>
<p>We have chosen to implement a variation published in the 2015 paper
“Count-Min-Log sketch: Approximating counting with approximate counters” by
Pitel and Fouquier. In this paper, the authors use a variant of the count-min
sketch with conservative updating that uses log-based, approximate counters
instead of linear counters to improve the average relative error at a constant
memory footprint.</p>
<p>A conservative update only increases the counts in the sketch by the minimum
amount needed to ensure the estimate remains accurate. This was applied to
count-min sketches by Goyal and Daume in “Approximate scalable bounded space
sketch for large data NLP” in 2011. Instead of incrementing each of the <cite>d</cite>
counters associated with an element, only those counters that equal the minimum
value of the <cite>d</cite> counters is updated. This helps to reduce the error at the
expense of finding the minimum count value for the <cite>d</cite> counters before
incrementing. This seems a small price to pay for improved performance.
Unfortunately, there are no guarantees that have been proven with conservative
updating, but at least the error is never increased and empirical studies show
a reduction in the error.</p>
<p>The paper “Approximate counting: a detailed analysis” by Flajolet in 1985
describes the behavior of the <cite>w*d</cite> log-based counters used in the count-min
sketch (log8 &amp; log16 variants). When adding an element to the sketch, if any of
the <cite>d</cite> counters associated with the element are to be updated, then those
counters are incremented with probability <cite>x**(-c)</cite> where <cite>x</cite> is the base of the
log counter and <cite>c</cite> is the current value stored in that log counter. The paper
shows that there is an unbiased estimate of the count <cite>N</cite> given by
<cite>(x**c - 1)/(x - 1)</cite> that has a variance of <cite>(x-1)N(N-1)/2</cite>. A more recent
analysis (2020) in “Optimal bounds for approximate counting” by Nelson and Yu
show that these counters are optimal in terms of space (memory) required.</p>
<p>We have also added one additional feature that is not discussed in the paper.
We split the values of our log-based counters into two parts. At the low end,
[0, num_reserved], we use linear counting and from (num_reserved, max_count] we
use the log-based counters. This allows for more accurate counting at the low
end at the expense of less accuracy on the high end. The default values for
num_reserved are 15 and 1023 for the 1-byte and 2-byte versions, respectively.</p>
<p>For the log-based counters we also set a max_count. This is the maximum value
that you want to be able to count to for any given element. By default, this is
set to 2**32 - 1 to match the limit of the linear version. This is useful if you
plan to filter out elements that have too high of a count. For example, if you
are going to filter out elements that have been observed 100M times or more,
then there is no need for the max_value to be 2**32-1. Instead you can set it to
be 100M which will improve the accuracy of your log counters, by using a smaller
base <cite>x</cite>, since a smaller range of values is now covered by the same number of
bits. The base x of the log counters is determined by the num_reserved and the
max_count.</p>
<p>To get an estimated count for an element, the following steps are done:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Return the minimum value stored in the d counters associated with key</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">get_min_c</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
<span class="k">if</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="n">num_reserved</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">c</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">cprime</span> <span class="o">=</span> <span class="n">c</span> <span class="o">-</span> <span class="n">num_reserved</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="n">cprime</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">num_reserved</span>
</pre></div>
</div>
<p>where <cite>x</cite> is the base of the log counters.</p>
<p>For the linear count-min sketch, merging two sketches (must have the same <cite>w</cite>
&amp; <cite>d</cite>) is simply a matter of an element-wise sum between the two arrays of
counters; ensuring that you do not exceed the 4-byte maximum value of 2**32 - 1.
For the log-based count-min sketch, it is a bit more complicated. For each of
the <cite>w*d</cite> counters, convert the stored log value into the corresponding
estimated count value. Add the two values together to get the value v that is
to be estimated in the merged log counter:</p>
<ul class="simple">
<li><dl class="simple">
<dt>If v &lt;= num_reserved</dt><dd><ul>
<li><p>store v in the log counter</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>If v &gt;= max_count</dt><dd><ul>
<li><p>store the max uint value in the log counter</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Else</dt><dd><ul>
<li><p>find the corresponding log values that bound v and round to the nearest log value</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</div>
<div class="section" id="testing">
<h2>Testing<a class="headerlink" href="#testing" title="Permalink to this headline">¶</a></h2>
<p>Given that these are probablistic in nature, writing traditional software tests
is a bit challenging. We have written statistical tests that should pass the
vast majority of the time. The tests can be found in tests/test_countmin.py</p>
<p>We start by testing that the error guarantees are met for the linear cms.</p>
<p>For the log8 and log16 versions, we have two separate tests. The first is checking
that the log updating provides an unbiased estimate. In order to limit the biased
errors introduced by collisions in the count-min sketch, we set the width to be eight
times the number of unique keys inserted into the sketch. We use a t-test to test the
null hypothesis that the mean of the difference between the true count and the
estimated count is 0. The test asserts that we should fail to reject the null
hypothesis at a 99.9% confidence level. These tests are located in
<code class="code docutils literal notranslate"><span class="pre">test_update_log8_?()</span></code> and <code class="code docutils literal notranslate"><span class="pre">test_update_log16_?()</span></code>, where we have a test
for both adding keys as a list and adding keys as a dictionary.</p>
<p>The second set of tests ensures that merging two count-min sketches together give an
unbiased estimate. Again, to limit the biased errors introduced by collisions
in the count-min sketch, we set the width = 8 x n_unique_keys. We use a t-test to
test the null hypothesis that the mean of the difference between the true count and
estimated count is 0. The test asserts that we should fail to reject the null
hypothesisat a 99.9% confidence level. These tests are in <code class="code docutils literal notranslate"><span class="pre">test_merge_?()</span></code>.</p>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="hyperloglog.html" class="btn btn-neutral float-left" title="HyperLogLog++" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="heavyhitters.html" class="btn btn-neutral float-right" title="Heavy-Hitters" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Matthew Hendrey.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>